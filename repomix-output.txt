This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-08T16:49:28.644Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
examples/
  image_steps.py
  main.py
src/
  pixelpiper/
    __init__.py
    callbacks.py
    decorators.py
    pipeline.py
    types.py

================================================================
Repository Files
================================================================

================
File: examples/image_steps.py
================
# image_steps.py
from PIL import Image
from typing import Dict, Any
from .pipeline import PipelineStep, StepResult, StepStatus
from .decorators import step, requires, provides, timeout, max_retries

class ImageResizeStep(PipelineStep):
    """Resizes an image according to an input size factor."""
    @step(name="image_resize")
    @requires("input_size")
    @provides("resized_image", "resize_factor")
    @timeout(10.0)
    @max_retries(2)
    async def process(self, image: Image.Image, context: Dict[str, Any]) -> StepResult:
        try:
            target_size = context["input_size"]
            width, height = image.size
            resize_factor = target_size / max(width, height)
            new_size = (int(width * resize_factor), int(height * resize_factor))
            resized_image = image.resize(new_size)
            return StepResult(status=StepStatus.COMPLETED, data={
                "resized_image": resized_image,
                "resize_factor": resize_factor
            })
        except Exception as e:
            return StepResult(status=StepStatus.FAILED, data={}, error=str(e))

================
File: examples/main.py
================
# main.py
import asyncio
from PIL import Image
from pixelpiper.pipeline import Pipeline, PipelineConfig
from pixelpiper.callbacks import TimingCallback
from examples.image_steps import ImageResizeStep

async def main() -> None:
    config = PipelineConfig(max_retries=3, timeout=15.0, ui_url="http://localhost:3000")
    pipeline = Pipeline(config, callbacks=[TimingCallback()])
    pipeline.add_step(ImageResizeStep())
    image = Image.new("RGB", (800, 600), color="white")
    context = {"input_size": 400}
    try:
        result = await pipeline.run(image, context)
        print("Pipeline completed successfully!")
        print("Results:", result)
    except Exception as e:
        print("Pipeline failed:", e)

if __name__ == "__main__":
    asyncio.run(main())

================
File: src/pixelpiper/__init__.py
================
from .pipeline import Pipeline, PipelineConfig, PipelineStep
from .callbacks import PipelineCallback, TimingCallback
from .decorators import step, requires, provides, timeout, max_retries
from .types import StepResult, StepStatus

================
File: src/pixelpiper/callbacks.py
================
import time
import logging
from typing import Dict
from .types import StepResult  # Common types extracted to a separate module

logger = logging.getLogger(__name__)

class PipelineCallback:
    """Interface for pipeline callbacks."""
    async def before_step(self, step_name: str) -> None:
        pass

    async def after_step(self, step_name: str, result: StepResult) -> None:
        pass

class TimingCallback(PipelineCallback):
    """Callback that tracks execution time for pipeline steps."""
    def __init__(self) -> None:
        self.step_timings: Dict[str, float] = {}
        self._current_start: float = 0.0

    async def before_step(self, step_name: str) -> None:
        self._current_start = time.time()
        logger.info("Starting step", extra={"step": step_name})

    async def after_step(self, step_name: str, result: StepResult) -> None:
        duration = time.time() - self._current_start
        self.step_timings[step_name] = duration
        logger.info("Finished step", extra={"step": step_name, "duration": duration, "status": result.status.value})

================
File: src/pixelpiper/decorators.py
================
from typing import Callable, Optional, Set

class StepMetadata:
    """Metadata storage for step decorators."""
    def __init__(self) -> None:
        self.requires: Set[str] = set()
        self.provides: Set[str] = set()
        self.timeout: Optional[float] = None
        self.max_retries: Optional[int] = None
        self.name: Optional[str] = None

def _ensure_metadata(method: Callable) -> StepMetadata:
    """Ensure that a method has a _step_metadata attribute."""
    if not hasattr(method, '_step_metadata'):
        method._step_metadata = StepMetadata()
    return method._step_metadata

def step(name: Optional[str] = None) -> Callable:
    """Decorator to mark a method as a pipeline step."""
    def decorator(method: Callable) -> Callable:
        metadata = _ensure_metadata(method)
        metadata.name = name if name is not None else method.__name__
        return method
    return decorator

def requires(*keys: str) -> Callable:
    """Decorator to specify required context keys for a step."""
    def decorator(method: Callable) -> Callable:
        metadata = _ensure_metadata(method)
        metadata.requires.update(keys)
        return method
    return decorator

def provides(*keys: str) -> Callable:
    """Decorator to specify provided context keys for a step."""
    def decorator(method: Callable) -> Callable:
        metadata = _ensure_metadata(method)
        metadata.provides.update(keys)
        return method
    return decorator

def timeout(seconds: float) -> Callable:
    """Decorator to specify a custom timeout for a step."""
    def decorator(method: Callable) -> Callable:
        metadata = _ensure_metadata(method)
        metadata.timeout = seconds
        return method
    return decorator

def max_retries(count: int) -> Callable:
    """Decorator to specify a custom retry count for a step."""
    def decorator(method: Callable) -> Callable:
        metadata = _ensure_metadata(method)
        metadata.max_retries = count
        return method
    return decorator

================
File: src/pixelpiper/pipeline.py
================
import asyncio
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from PIL import Image
from .callbacks import PipelineCallback
from .types import StepResult, StepStatus

logger = logging.getLogger(__name__)

class PipelineStep(ABC):
    """Abstract base class for pipeline steps."""
    def __init__(self, name: Optional[str] = None) -> None:
        self._name = name or self.__class__.__name__
        self._required_context_keys: List[str] = []
        self._provided_context_keys: List[str] = []
        self._load_metadata()

    def _load_metadata(self) -> None:
      process_method = getattr(self.__class__, "process", None)
      if process_method and hasattr(process_method, "_step_metadata"):
          metadata = process_method._step_metadata
          if metadata.name:
              self._name = metadata.name
          self._required_context_keys = list(metadata.requires)
          self._provided_context_keys = list(metadata.provides)


    @property
    def name(self) -> str:
        return self._name

    @property
    def required_context_keys(self) -> List[str]:
        return self._required_context_keys

    @property
    def provided_context_keys(self) -> List[str]:
        return self._provided_context_keys

    def validate_context(self, context: Dict[str, Any]) -> bool:
        missing = [key for key in self.required_context_keys if key not in context]
        if missing:
            logger.warning("Missing required keys", extra={"step": self.name, "missing": missing})
        return not missing

    @abstractmethod
    async def process(self, image: Image.Image, context: Dict[str, Any]) -> StepResult:
        """Process the input image and update the context."""
        pass

@dataclass
class PipelineConfig:
    """Configuration for pipeline execution."""
    max_retries: int = 3
    retry_delay: float = 1.0
    timeout: float = 30.0
    validate_outputs: bool = True

class Pipeline:
    """Pipeline executor for running a series of steps."""
    def __init__(self, config: Optional[PipelineConfig] = None, callbacks: Optional[List[PipelineCallback]] = None) -> None:
        self.steps: List[PipelineStep] = []
        self.context: Dict[str, Any] = {}
        self.config = config or PipelineConfig()
        self.callbacks: List[PipelineCallback] = callbacks or []
        # UI callback logic removed

    def add_step(self, step: PipelineStep) -> None:
        self.steps.append(step)

    def add_callback(self, callback: PipelineCallback) -> None:
        self.callbacks.append(callback)

    async def _run_step(self, step: PipelineStep, image: Image.Image) -> StepResult:
        timeout_val = self.config.timeout
        retries = self.config.max_retries
        # Adjust timeout and retries from metadata if available.
        process_method = step.__class__.process
        if hasattr(process_method, "_step_metadata"):
            metadata = process_method._step_metadata
            if metadata.timeout is not None:
                timeout_val = metadata.timeout
            if metadata.max_retries is not None:
                retries = metadata.max_retries

        for attempt in range(1, retries + 1):
            try:
                logger.info("Executing step", extra={"step": step.name, "attempt": attempt})
                async with asyncio.timeout(timeout_val):
                    for callback in self.callbacks:
                        await callback.before_step(step.name)
                    result = await step.process(image, self.context)
                    for callback in self.callbacks:
                        await callback.after_step(step.name, result)
                    return result
            except Exception as e:
                logger.error("Error in step", extra={"step": step.name, "attempt": attempt, "error": str(e)})
                if attempt < retries:
                    await asyncio.sleep(self.config.retry_delay)
                else:
                    failed = StepResult(status=StepStatus.FAILED, data={}, error=str(e))
                    for callback in self.callbacks:
                        await callback.after_step(step.name, failed)
                    return failed

    async def run(self, image: Image.Image, initial_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        self.context = initial_context or {}
        try:
            for step in self.steps:
                logger.info("Starting step", extra={"step": step.name})
                if not step.validate_context(self.context):
                    raise ValueError(f"Missing keys for {step.name}")
                result = await self._run_step(step, image)
                if result.status == StepStatus.FAILED:
                    raise RuntimeError(f"Step {step.name} failed: {result.error}")
                self.context.update(result.data)
                logger.info("Completed step", extra={"step": step.name})
            return self.context
        finally:
            # Ensure all callbacks are closed if applicable.
            for callback in self.callbacks:
                if hasattr(callback, "close") and callable(callback.close):
                    await callback.close()

================
File: src/pixelpiper/types.py
================
# types.py
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, Optional

class StepStatus(Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"

@dataclass
class StepResult:
    status: StepStatus
    data: Dict[str, Any]
    error: Optional[str] = None
